<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="ja">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: BS::multi_future&lt; T &gt; クラステンプレート</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- 構築: Doxygen 1.14.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','検索',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('class_b_s_1_1multi__future.html','','class_b_s_1_1multi__future-members'); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">読み取り中…</div>
<div class="SRStatus" id="Searching">検索中…</div>
<div class="SRStatus" id="NoMatches">一致する文字列を見つけられません</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">BS::multi_future&lt; T &gt; クラステンプレート</div></div>
</div><!--header-->
<div class="contents">

<p>A helper class to facilitate waiting for and/or getting the results of multiple futures at once.  
 <a href="#details">[詳解]</a></p>

<p><code>#include &lt;<a class="el" href="_b_s__thread__pool_8hpp_source.html">BS_thread_pool.hpp</a>&gt;</code></p>
<div class="dynheader">
BS::multi_future&lt; T &gt; の継承関係図</div>
<div class="dyncontent">
 <div class="center">
  <img src="class_b_s_1_1multi__future.png" alt=""/>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-methods" class="groupheader"><a id="pub-methods" name="pub-methods"></a>
公開メンバ関数</h2></td></tr>
<tr class="memitem:ad2b19061c7db1d50a35858e17dcd2268" id="r_ad2b19061c7db1d50a35858e17dcd2268"><td class="memItemLeft" align="right" valign="top">std::conditional_t&lt; std::is_void_v&lt; T &gt;, void, std::vector&lt; T &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad2b19061c7db1d50a35858e17dcd2268">get</a> ()</td></tr>
<tr class="memdesc:ad2b19061c7db1d50a35858e17dcd2268"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the results from all the futures stored in this <span class="tt"><a class="el" href="class_b_s_1_1multi__future.html" title="A helper class to facilitate waiting for and/or getting the results of multiple futures at once.">BS::multi_future</a></span>, rethrowing any stored exceptions.  <br /></td></tr>
<tr class="memitem:ad00db759f47fa31f85f52e53589f16e7" id="r_ad00db759f47fa31f85f52e53589f16e7"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad00db759f47fa31f85f52e53589f16e7">ready_count</a> () const</td></tr>
<tr class="memdesc:ad00db759f47fa31f85f52e53589f16e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check how many of the futures stored in this <span class="tt"><a class="el" href="class_b_s_1_1multi__future.html" title="A helper class to facilitate waiting for and/or getting the results of multiple futures at once.">BS::multi_future</a></span> are ready.  <br /></td></tr>
<tr class="memitem:a1c282cf3dda2cbcfe039c5bb2b635290" id="r_a1c282cf3dda2cbcfe039c5bb2b635290"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1c282cf3dda2cbcfe039c5bb2b635290">valid</a> () const noexcept</td></tr>
<tr class="memdesc:a1c282cf3dda2cbcfe039c5bb2b635290"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if all the futures stored in this <span class="tt"><a class="el" href="class_b_s_1_1multi__future.html" title="A helper class to facilitate waiting for and/or getting the results of multiple futures at once.">BS::multi_future</a></span> are valid.  <br /></td></tr>
<tr class="memitem:a05073ed8d37b939c9440ac8789b69ba7" id="r_a05073ed8d37b939c9440ac8789b69ba7"><td class="memItemLeft" align="right" valign="top"><a id="a05073ed8d37b939c9440ac8789b69ba7" name="a05073ed8d37b939c9440ac8789b69ba7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>wait</b> () const</td></tr>
<tr class="memdesc:a05073ed8d37b939c9440ac8789b69ba7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for all the futures stored in this <span class="tt"><a class="el" href="class_b_s_1_1multi__future.html" title="A helper class to facilitate waiting for and/or getting the results of multiple futures at once.">BS::multi_future</a></span>. <br /></td></tr>
<tr class="memitem:a381744c63b88eee1df425b5ce7b5e904" id="r_a381744c63b88eee1df425b5ce7b5e904"><td class="memTemplParams" colspan="2">template&lt;typename R, typename P&gt; </td></tr>
<tr class="memitem:a381744c63b88eee1df425b5ce7b5e904 template"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a381744c63b88eee1df425b5ce7b5e904">wait_for</a> (const std::chrono::duration&lt; R, P &gt; &amp;duration) const</td></tr>
<tr class="memdesc:a381744c63b88eee1df425b5ce7b5e904"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for all the futures stored in this <span class="tt"><a class="el" href="class_b_s_1_1multi__future.html" title="A helper class to facilitate waiting for and/or getting the results of multiple futures at once.">BS::multi_future</a></span>, but stop waiting after the specified duration has passed. This function first waits for the first future for the desired duration. If that future is ready before the duration expires, this function waits for the second future for whatever remains of the duration. It continues similarly until the duration expires.  <br /></td></tr>
<tr class="memitem:ad7e095316d61714456281cb3d30325a1" id="r_ad7e095316d61714456281cb3d30325a1"><td class="memTemplParams" colspan="2">template&lt;typename C, typename D&gt; </td></tr>
<tr class="memitem:ad7e095316d61714456281cb3d30325a1 template"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad7e095316d61714456281cb3d30325a1">wait_until</a> (const std::chrono::time_point&lt; C, D &gt; &amp;timeout_time) const</td></tr>
<tr class="memdesc:ad7e095316d61714456281cb3d30325a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for all the futures stored in this <span class="tt"><a class="el" href="class_b_s_1_1multi__future.html" title="A helper class to facilitate waiting for and/or getting the results of multiple futures at once.">BS::multi_future</a></span>, but stop waiting after the specified time point has been reached. This function first waits for the first future until the desired time point. If that future is ready before the time point is reached, this function waits for the second future until the desired time point. It continues similarly until the time point is reached.  <br /></td></tr>
</table>
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">詳解</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename T&gt;<br />
class BS::multi_future&lt; T &gt;</div><p>A helper class to facilitate waiting for and/or getting the results of multiple futures at once. </p>
<dl class="tparams"><dt>テンプレート引数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The return type of the futures. </td></tr>
  </table>
  </dd>
</dl>
</div><a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">関数詳解</h2>
<a id="ad2b19061c7db1d50a35858e17dcd2268" name="ad2b19061c7db1d50a35858e17dcd2268"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2b19061c7db1d50a35858e17dcd2268">&#9670;&#160;</a></span>get()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::conditional_t&lt; std::is_void_v&lt; T &gt;, void, std::vector&lt; T &gt; &gt; <a class="el" href="class_b_s_1_1multi__future.html">BS::multi_future</a>&lt; T &gt;::get </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the results from all the futures stored in this <span class="tt"><a class="el" href="class_b_s_1_1multi__future.html" title="A helper class to facilitate waiting for and/or getting the results of multiple futures at once.">BS::multi_future</a></span>, rethrowing any stored exceptions. </p>
<dl class="section return"><dt>戻り値</dt><dd>If the futures return <span class="tt">void</span>, this function returns <span class="tt">void</span> as well. Otherwise, it returns a vector containing the results. </dd></dl>

</div>
</div>
<a id="ad00db759f47fa31f85f52e53589f16e7" name="ad00db759f47fa31f85f52e53589f16e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad00db759f47fa31f85f52e53589f16e7">&#9670;&#160;</a></span>ready_count()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="class_b_s_1_1multi__future.html">BS::multi_future</a>&lt; T &gt;::ready_count </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check how many of the futures stored in this <span class="tt"><a class="el" href="class_b_s_1_1multi__future.html" title="A helper class to facilitate waiting for and/or getting the results of multiple futures at once.">BS::multi_future</a></span> are ready. </p>
<dl class="section return"><dt>戻り値</dt><dd>The number of ready futures. </dd></dl>

</div>
</div>
<a id="a1c282cf3dda2cbcfe039c5bb2b635290" name="a1c282cf3dda2cbcfe039c5bb2b635290"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c282cf3dda2cbcfe039c5bb2b635290">&#9670;&#160;</a></span>valid()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_b_s_1_1multi__future.html">BS::multi_future</a>&lt; T &gt;::valid </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if all the futures stored in this <span class="tt"><a class="el" href="class_b_s_1_1multi__future.html" title="A helper class to facilitate waiting for and/or getting the results of multiple futures at once.">BS::multi_future</a></span> are valid. </p>
<dl class="section return"><dt>戻り値</dt><dd><span class="tt">true</span> if all futures are valid, <span class="tt">false</span> if at least one of the futures is not valid. </dd></dl>

</div>
</div>
<a id="a381744c63b88eee1df425b5ce7b5e904" name="a381744c63b88eee1df425b5ce7b5e904"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a381744c63b88eee1df425b5ce7b5e904">&#9670;&#160;</a></span>wait_for()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;typename R, typename P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_b_s_1_1multi__future.html">BS::multi_future</a>&lt; T &gt;::wait_for </td>
          <td>(</td>
          <td class="paramtype">const std::chrono::duration&lt; R, P &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>duration</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wait for all the futures stored in this <span class="tt"><a class="el" href="class_b_s_1_1multi__future.html" title="A helper class to facilitate waiting for and/or getting the results of multiple futures at once.">BS::multi_future</a></span>, but stop waiting after the specified duration has passed. This function first waits for the first future for the desired duration. If that future is ready before the duration expires, this function waits for the second future for whatever remains of the duration. It continues similarly until the duration expires. </p>
<dl class="tparams"><dt>テンプレート引数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>An arithmetic type representing the number of ticks to wait. </td></tr>
    <tr><td class="paramname">P</td><td>An <span class="tt">std::ratio</span> representing the length of each tick in seconds. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">duration</td><td>The amount of time to wait. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd><span class="tt">true</span> if all futures have been waited for before the duration expired, <span class="tt">false</span> otherwise. </dd></dl>

</div>
</div>
<a id="ad7e095316d61714456281cb3d30325a1" name="ad7e095316d61714456281cb3d30325a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7e095316d61714456281cb3d30325a1">&#9670;&#160;</a></span>wait_until()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;typename C, typename D&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_b_s_1_1multi__future.html">BS::multi_future</a>&lt; T &gt;::wait_until </td>
          <td>(</td>
          <td class="paramtype">const std::chrono::time_point&lt; C, D &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>timeout_time</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wait for all the futures stored in this <span class="tt"><a class="el" href="class_b_s_1_1multi__future.html" title="A helper class to facilitate waiting for and/or getting the results of multiple futures at once.">BS::multi_future</a></span>, but stop waiting after the specified time point has been reached. This function first waits for the first future until the desired time point. If that future is ready before the time point is reached, this function waits for the second future until the desired time point. It continues similarly until the time point is reached. </p>
<dl class="tparams"><dt>テンプレート引数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">C</td><td>The type of the clock used to measure time. </td></tr>
    <tr><td class="paramname">D</td><td>An <span class="tt">std::chrono::duration</span> type used to indicate the time point. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeout_time</td><td>The time point at which to stop waiting. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd><span class="tt">true</span> if all futures have been waited for before the time point was reached, <span class="tt">false</span> otherwise. </dd></dl>

</div>
</div>
<hr/>このクラス詳解は次のファイルから抽出されました:<ul>
<li><a class="el" href="_b_s__thread__pool_8hpp_source.html">BS_thread_pool.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a href="namespace_b_s.html">BS</a></li><li class="navelem"><a href="class_b_s_1_1multi__future.html">multi_future</a></li>
    <li class="footer">構築: <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0 </li>
  </ul>
</div>
</body>
</html>
