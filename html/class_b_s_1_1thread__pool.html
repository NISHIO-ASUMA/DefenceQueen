<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="ja">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: BS::thread_pool&lt; OptFlags &gt; クラステンプレート</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- 構築: Doxygen 1.14.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','検索',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('class_b_s_1_1thread__pool.html','','class_b_s_1_1thread__pool-members'); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">読み取り中…</div>
<div class="SRStatus" id="Searching">検索中…</div>
<div class="SRStatus" id="NoMatches">一致する文字列を見つけられません</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">BS::thread_pool&lt; OptFlags &gt; クラステンプレート</div></div>
</div><!--header-->
<div class="contents">

<p>A fast, lightweight, modern, and easy-to-use C++17/C++20/C++23 thread pool class.  
 <a href="#details">[詳解]</a></p>

<p><code>#include &lt;<a class="el" href="_b_s__thread__pool_8hpp_source.html">BS_thread_pool.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-methods" class="groupheader"><a id="pub-methods" name="pub-methods"></a>
公開メンバ関数</h2></td></tr>
<tr class="memitem:a3b6e01d23a9935412747bd4c9d83fc6c" id="r_a3b6e01d23a9935412747bd4c9d83fc6c"><td class="memItemLeft" align="right" valign="top"><a id="a3b6e01d23a9935412747bd4c9d83fc6c" name="a3b6e01d23a9935412747bd4c9d83fc6c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>thread_pool</b> ()</td></tr>
<tr class="memdesc:a3b6e01d23a9935412747bd4c9d83fc6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a new thread pool. The number of threads will be the total number of hardware threads available, as reported by the implementation. This is usually determined by the number of cores in the CPU. If a core is hyperthreaded, it will count as two threads. <br /></td></tr>
<tr class="memitem:a0e0296afdd18d144fd96d27945426529" id="r_a0e0296afdd18d144fd96d27945426529"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0e0296afdd18d144fd96d27945426529">thread_pool</a> (const std::size_t num_threads)</td></tr>
<tr class="memdesc:a0e0296afdd18d144fd96d27945426529"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a new thread pool with the specified number of threads.  <br /></td></tr>
<tr class="memitem:a0c2bfc615db57530a97ae789987ae6d0" id="r_a0c2bfc615db57530a97ae789987ae6d0"><td class="memTemplParams" colspan="2">template&lt;BS_THREAD_POOL_INIT_FUNC_CONCEPT(F)&gt; </td></tr>
<tr class="memitem:a0c2bfc615db57530a97ae789987ae6d0 template"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0c2bfc615db57530a97ae789987ae6d0">thread_pool</a> (F &amp;&amp;init)</td></tr>
<tr class="memdesc:a0c2bfc615db57530a97ae789987ae6d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a new thread pool with the specified initialization function.  <br /></td></tr>
<tr class="memitem:a60e6550ac7332ead9af50936ae5c5a3d" id="r_a60e6550ac7332ead9af50936ae5c5a3d"><td class="memTemplParams" colspan="2">template&lt;BS_THREAD_POOL_INIT_FUNC_CONCEPT(F)&gt; </td></tr>
<tr class="memitem:a60e6550ac7332ead9af50936ae5c5a3d template"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a60e6550ac7332ead9af50936ae5c5a3d">thread_pool</a> (const std::size_t num_threads, F &amp;&amp;init)</td></tr>
<tr class="memdesc:a60e6550ac7332ead9af50936ae5c5a3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a new thread pool with the specified number of threads and initialization function.  <br /></td></tr>
<tr class="memitem:af59f658c7180d7fcf460224b7181e7ff" id="r_af59f658c7180d7fcf460224b7181e7ff"><td class="memItemLeft" align="right" valign="top"><a id="af59f658c7180d7fcf460224b7181e7ff" name="af59f658c7180d7fcf460224b7181e7ff"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>thread_pool</b> (const <a class="el" href="class_b_s_1_1thread__pool.html">thread_pool</a> &amp;)=delete</td></tr>
<tr class="memitem:a14da326f5fcd49f1bc4756ff0a351162" id="r_a14da326f5fcd49f1bc4756ff0a351162"><td class="memItemLeft" align="right" valign="top"><a id="a14da326f5fcd49f1bc4756ff0a351162" name="a14da326f5fcd49f1bc4756ff0a351162"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>thread_pool</b> (<a class="el" href="class_b_s_1_1thread__pool.html">thread_pool</a> &amp;&amp;)=delete</td></tr>
<tr class="memitem:af3f8616681b52f7fdf09acf179d108bf" id="r_af3f8616681b52f7fdf09acf179d108bf"><td class="memItemLeft" align="right" valign="top"><a id="af3f8616681b52f7fdf09acf179d108bf" name="af3f8616681b52f7fdf09acf179d108bf"></a>
<a class="el" href="class_b_s_1_1thread__pool.html">thread_pool</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="class_b_s_1_1thread__pool.html">thread_pool</a> &amp;)=delete</td></tr>
<tr class="memitem:ab2b38b8eca1683416aaa563f2c17b47a" id="r_ab2b38b8eca1683416aaa563f2c17b47a"><td class="memItemLeft" align="right" valign="top"><a id="ab2b38b8eca1683416aaa563f2c17b47a" name="ab2b38b8eca1683416aaa563f2c17b47a"></a>
<a class="el" href="class_b_s_1_1thread__pool.html">thread_pool</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="class_b_s_1_1thread__pool.html">thread_pool</a> &amp;&amp;)=delete</td></tr>
<tr class="memitem:af914f56422495eb7a5e8ccd93e442e73" id="r_af914f56422495eb7a5e8ccd93e442e73"><td class="memItemLeft" align="right" valign="top"><a id="af914f56422495eb7a5e8ccd93e442e73" name="af914f56422495eb7a5e8ccd93e442e73"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>~thread_pool</b> () noexcept</td></tr>
<tr class="memdesc:af914f56422495eb7a5e8ccd93e442e73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destruct the thread pool. Waits for all tasks to complete, then destroys all threads. If a cleanup function was set, it will run in each thread right before it is destroyed. Note that if the pool is paused, then any tasks still in the queue will never be executed. <br /></td></tr>
<tr class="memitem:a2227c23c57235a364397aff24dbe35c9" id="r_a2227c23c57235a364397aff24dbe35c9"><td class="memTemplParams" colspan="2">template&lt;typename T1, typename T2, typename T = common_index_type_t&lt;T1, T2&gt;, typename F&gt; </td></tr>
<tr class="memitem:a2227c23c57235a364397aff24dbe35c9 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2227c23c57235a364397aff24dbe35c9">detach_blocks</a> (const T1 first_index, const T2 index_after_last, F &amp;&amp;block, const std::size_t num_blocks=0, const <a class="el" href="namespace_b_s.html#a76f70ed782c6c8c95fbb1e7d3cb4656e">priority_t</a> <a class="el" href="namespace_b_s.html#ae1a882c1a2584cb3570b567595c8027ba20e966bd58a0ecab6eecb8d1cbdd022b">priority</a>=0)</td></tr>
<tr class="memdesc:a2227c23c57235a364397aff24dbe35c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parallelize a loop by automatically splitting it into blocks and submitting each block separately to the queue, with the specified priority. The block function takes two arguments, the start and end of the block, so that it is only called once per block, but it is up to the user make sure the block function correctly deals with all the indices in each block. Does not return a <span class="tt"><a class="el" href="class_b_s_1_1multi__future.html" title="A helper class to facilitate waiting for and/or getting the results of multiple futures at once.">BS::multi_future</a></span>, so the user must use <span class="tt"><a class="el" href="#ae4fdcde4657ca01e3f6d0af108284809" title="Wait for tasks to be completed. Normally, this function waits for all tasks, both those that are curr...">wait()</a></span> or some other method to ensure that the loop finishes executing, otherwise bad things will happen.  <br /></td></tr>
<tr class="memitem:a24a2a5d7219f89fff6aa7b33bc8a7994" id="r_a24a2a5d7219f89fff6aa7b33bc8a7994"><td class="memTemplParams" colspan="2">template&lt;typename T1, typename T2, typename T = common_index_type_t&lt;T1, T2&gt;, typename F&gt; </td></tr>
<tr class="memitem:a24a2a5d7219f89fff6aa7b33bc8a7994 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a24a2a5d7219f89fff6aa7b33bc8a7994">detach_loop</a> (const T1 first_index, const T2 index_after_last, F &amp;&amp;loop, const std::size_t num_blocks=0, const <a class="el" href="namespace_b_s.html#a76f70ed782c6c8c95fbb1e7d3cb4656e">priority_t</a> <a class="el" href="namespace_b_s.html#ae1a882c1a2584cb3570b567595c8027ba20e966bd58a0ecab6eecb8d1cbdd022b">priority</a>=0)</td></tr>
<tr class="memdesc:a24a2a5d7219f89fff6aa7b33bc8a7994"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parallelize a loop by automatically splitting it into blocks and submitting each block separately to the queue, with the specified priority. The loop function takes one argument, the loop index, so that it is called many times per block. Does not return a <span class="tt"><a class="el" href="class_b_s_1_1multi__future.html" title="A helper class to facilitate waiting for and/or getting the results of multiple futures at once.">BS::multi_future</a></span>, so the user must use <span class="tt"><a class="el" href="#ae4fdcde4657ca01e3f6d0af108284809" title="Wait for tasks to be completed. Normally, this function waits for all tasks, both those that are curr...">wait()</a></span> or some other method to ensure that the loop finishes executing, otherwise bad things will happen.  <br /></td></tr>
<tr class="memitem:affb462961cfe82a65097a4999f22ce8a" id="r_affb462961cfe82a65097a4999f22ce8a"><td class="memTemplParams" colspan="2">template&lt;typename T1, typename T2, typename T = common_index_type_t&lt;T1, T2&gt;, typename F&gt; </td></tr>
<tr class="memitem:affb462961cfe82a65097a4999f22ce8a template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#affb462961cfe82a65097a4999f22ce8a">detach_sequence</a> (const T1 first_index, const T2 index_after_last, F &amp;&amp;sequence, const <a class="el" href="namespace_b_s.html#a76f70ed782c6c8c95fbb1e7d3cb4656e">priority_t</a> <a class="el" href="namespace_b_s.html#ae1a882c1a2584cb3570b567595c8027ba20e966bd58a0ecab6eecb8d1cbdd022b">priority</a>=0)</td></tr>
<tr class="memdesc:affb462961cfe82a65097a4999f22ce8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submit a sequence of tasks enumerated by indices to the queue, with the specified priority. The sequence function takes one argument, the task index, and will be called once per index. Does not return a <span class="tt"><a class="el" href="class_b_s_1_1multi__future.html" title="A helper class to facilitate waiting for and/or getting the results of multiple futures at once.">BS::multi_future</a></span>, so the user must use <span class="tt"><a class="el" href="#ae4fdcde4657ca01e3f6d0af108284809" title="Wait for tasks to be completed. Normally, this function waits for all tasks, both those that are curr...">wait()</a></span> or some other method to ensure that the sequence finishes executing, otherwise bad things will happen.  <br /></td></tr>
<tr class="memitem:ac5effe10fd4156ea28c7a5c61997c6e7" id="r_ac5effe10fd4156ea28c7a5c61997c6e7"><td class="memTemplParams" colspan="2">template&lt;typename F&gt; </td></tr>
<tr class="memitem:ac5effe10fd4156ea28c7a5c61997c6e7 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac5effe10fd4156ea28c7a5c61997c6e7">detach_task</a> (F &amp;&amp;task, const <a class="el" href="namespace_b_s.html#a76f70ed782c6c8c95fbb1e7d3cb4656e">priority_t</a> <a class="el" href="namespace_b_s.html#ae1a882c1a2584cb3570b567595c8027ba20e966bd58a0ecab6eecb8d1cbdd022b">priority</a>=0)</td></tr>
<tr class="memdesc:ac5effe10fd4156ea28c7a5c61997c6e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submit a function with no arguments and no return value into the task queue, with the specified priority. To submit a function with arguments, enclose it in a lambda expression. Does not return a future, so the user must use <span class="tt"><a class="el" href="#ae4fdcde4657ca01e3f6d0af108284809" title="Wait for tasks to be completed. Normally, this function waits for all tasks, both those that are curr...">wait()</a></span> or some other method to ensure that the task finishes executing, otherwise bad things will happen.  <br /></td></tr>
<tr class="memitem:a70a96809451e3b894b4914f73943b8b8" id="r_a70a96809451e3b894b4914f73943b8b8"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a70a96809451e3b894b4914f73943b8b8">get_tasks_queued</a> () const</td></tr>
<tr class="memdesc:a70a96809451e3b894b4914f73943b8b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of tasks currently waiting in the queue to be executed by the threads.  <br /></td></tr>
<tr class="memitem:af797cf1b1c5290330beef12fc44a213f" id="r_af797cf1b1c5290330beef12fc44a213f"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af797cf1b1c5290330beef12fc44a213f">get_tasks_running</a> () const</td></tr>
<tr class="memdesc:af797cf1b1c5290330beef12fc44a213f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of tasks currently being executed by the threads.  <br /></td></tr>
<tr class="memitem:a8d29b6cfcb1a688a1bd0ec2cfd827b24" id="r_a8d29b6cfcb1a688a1bd0ec2cfd827b24"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8d29b6cfcb1a688a1bd0ec2cfd827b24">get_tasks_total</a> () const</td></tr>
<tr class="memdesc:a8d29b6cfcb1a688a1bd0ec2cfd827b24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the total number of unfinished tasks: either still waiting in the queue, or running in a thread. Note that <span class="tt"><a class="el" href="#a8d29b6cfcb1a688a1bd0ec2cfd827b24" title="Get the total number of unfinished tasks: either still waiting in the queue, or running in a thread....">get_tasks_total()</a> == <a class="el" href="#a70a96809451e3b894b4914f73943b8b8" title="Get the number of tasks currently waiting in the queue to be executed by the threads.">get_tasks_queued()</a> + <a class="el" href="#af797cf1b1c5290330beef12fc44a213f" title="Get the number of tasks currently being executed by the threads.">get_tasks_running()</a></span>.  <br /></td></tr>
<tr class="memitem:ab8ff9b7b79739ae9240833a9b939de65" id="r_ab8ff9b7b79739ae9240833a9b939de65"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab8ff9b7b79739ae9240833a9b939de65">get_thread_count</a> () const noexcept</td></tr>
<tr class="memdesc:ab8ff9b7b79739ae9240833a9b939de65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of threads in the pool.  <br /></td></tr>
<tr class="memitem:a8292a17d2c183df3f02c89804b70f4ec" id="r_a8292a17d2c183df3f02c89804b70f4ec"><td class="memItemLeft" align="right" valign="top">std::vector&lt; thread_t::id &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8292a17d2c183df3f02c89804b70f4ec">get_thread_ids</a> () const</td></tr>
<tr class="memdesc:a8292a17d2c183df3f02c89804b70f4ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a vector containing the unique identifiers for each of the pool's threads, as obtained by <span class="tt">std::thread::get_id()</span> (or <span class="tt">std::jthread::get_id()</span> in C++20 and later).  <br /></td></tr>
<tr class="memitem:a0e45f81e64dc34df12705c95132620b3" id="r_a0e45f81e64dc34df12705c95132620b3"><td class="memItemLeft" align="right" valign="top">BS_THREAD_POOL_IF_PAUSE_ENABLED bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0e45f81e64dc34df12705c95132620b3">is_paused</a> () const</td></tr>
<tr class="memdesc:a0e45f81e64dc34df12705c95132620b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether the pool is currently paused. Only enabled if the flag <span class="tt">BS:tp::pause</span> is enabled in the template parameter.  <br /></td></tr>
<tr class="memitem:a4b8a5bc00788adecc1d0be3fc18eae6c" id="r_a4b8a5bc00788adecc1d0be3fc18eae6c"><td class="memItemLeft" align="right" valign="top"><a id="a4b8a5bc00788adecc1d0be3fc18eae6c" name="a4b8a5bc00788adecc1d0be3fc18eae6c"></a>
BS_THREAD_POOL_IF_PAUSE_ENABLED void&#160;</td><td class="memItemRight" valign="bottom"><b>pause</b> ()</td></tr>
<tr class="memdesc:a4b8a5bc00788adecc1d0be3fc18eae6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pause the pool. The workers will temporarily stop retrieving new tasks out of the queue, although any tasks already executed will keep running until they are finished. Only enabled if the flag <span class="tt">BS:tp::pause</span> is enabled in the template parameter. <br /></td></tr>
<tr class="memitem:a5ae51d78ab371bbedaafdf5cb15fd786" id="r_a5ae51d78ab371bbedaafdf5cb15fd786"><td class="memItemLeft" align="right" valign="top"><a id="a5ae51d78ab371bbedaafdf5cb15fd786" name="a5ae51d78ab371bbedaafdf5cb15fd786"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>purge</b> ()</td></tr>
<tr class="memdesc:a5ae51d78ab371bbedaafdf5cb15fd786"><td class="mdescLeft">&#160;</td><td class="mdescRight">Purge all the tasks waiting in the queue. Tasks that are currently running will not be affected, but any tasks still waiting in the queue will be discarded, and will never be executed by the threads. Please note that there is no way to restore the purged tasks. <br /></td></tr>
<tr class="memitem:ad857e7bcb0740e7452b8b3f7f2b1f50c" id="r_ad857e7bcb0740e7452b8b3f7f2b1f50c"><td class="memItemLeft" align="right" valign="top"><a id="ad857e7bcb0740e7452b8b3f7f2b1f50c" name="ad857e7bcb0740e7452b8b3f7f2b1f50c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>reset</b> ()</td></tr>
<tr class="memdesc:ad857e7bcb0740e7452b8b3f7f2b1f50c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the pool with the total number of hardware threads available, as reported by the implementation. Waits for all currently running tasks to be completed, then destroys all threads in the pool and creates a new thread pool with the new number of threads. Any tasks that were waiting in the queue before the pool was reset will then be executed by the new threads. If the pool was paused before resetting it, the new pool will be paused as well. <br /></td></tr>
<tr class="memitem:a4a473029de41c6467945a9930fce7991" id="r_a4a473029de41c6467945a9930fce7991"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4a473029de41c6467945a9930fce7991">reset</a> (const std::size_t num_threads)</td></tr>
<tr class="memdesc:a4a473029de41c6467945a9930fce7991"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the pool with a new number of threads. Waits for all currently running tasks to be completed, then destroys all threads in the pool and creates a new thread pool with the new number of threads. Any tasks that were waiting in the queue before the pool was reset will then be executed by the new threads. If the pool was paused before resetting it, the new pool will be paused as well.  <br /></td></tr>
<tr class="memitem:a9f123ac3f05c1925b5941c1bed0f5a6d" id="r_a9f123ac3f05c1925b5941c1bed0f5a6d"><td class="memTemplParams" colspan="2">template&lt;BS_THREAD_POOL_INIT_FUNC_CONCEPT(F)&gt; </td></tr>
<tr class="memitem:a9f123ac3f05c1925b5941c1bed0f5a6d template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9f123ac3f05c1925b5941c1bed0f5a6d">reset</a> (F &amp;&amp;init)</td></tr>
<tr class="memdesc:a9f123ac3f05c1925b5941c1bed0f5a6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the pool with the total number of hardware threads available, as reported by the implementation, and a new initialization function. Waits for all currently running tasks to be completed, then destroys all threads in the pool and creates a new thread pool with the new number of threads and initialization function. Any tasks that were waiting in the queue before the pool was reset will then be executed by the new threads. If the pool was paused before resetting it, the new pool will be paused as well.  <br /></td></tr>
<tr class="memitem:a59eee365de519f55dd421b524ee6b663" id="r_a59eee365de519f55dd421b524ee6b663"><td class="memTemplParams" colspan="2">template&lt;BS_THREAD_POOL_INIT_FUNC_CONCEPT(F)&gt; </td></tr>
<tr class="memitem:a59eee365de519f55dd421b524ee6b663 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a59eee365de519f55dd421b524ee6b663">reset</a> (const std::size_t num_threads, F &amp;&amp;init)</td></tr>
<tr class="memdesc:a59eee365de519f55dd421b524ee6b663"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the pool with a new number of threads and a new initialization function. Waits for all currently running tasks to be completed, then destroys all threads in the pool and creates a new thread pool with the new number of threads and initialization function. Any tasks that were waiting in the queue before the pool was reset will then be executed by the new threads. If the pool was paused before resetting it, the new pool will be paused as well.  <br /></td></tr>
<tr class="memitem:a847135c2217e88c590b9ca4be39b6c7a" id="r_a847135c2217e88c590b9ca4be39b6c7a"><td class="memTemplParams" colspan="2">template&lt;BS_THREAD_POOL_INIT_FUNC_CONCEPT(F)&gt; </td></tr>
<tr class="memitem:a847135c2217e88c590b9ca4be39b6c7a template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a847135c2217e88c590b9ca4be39b6c7a">set_cleanup_func</a> (F &amp;&amp;cleanup)</td></tr>
<tr class="memdesc:a847135c2217e88c590b9ca4be39b6c7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the thread pool's cleanup function.  <br /></td></tr>
<tr class="memitem:a76f963d585dd582c78bbaf554185d5d4" id="r_a76f963d585dd582c78bbaf554185d5d4"><td class="memTemplParams" colspan="2">template&lt;typename T1, typename T2, typename T = common_index_type_t&lt;T1, T2&gt;, typename F, typename R = std::invoke_result_t&lt;std::decay_t&lt;F&gt;, T, T&gt;&gt; </td></tr>
<tr class="memitem:a76f963d585dd582c78bbaf554185d5d4 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_b_s_1_1multi__future.html">multi_future</a>&lt; R &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a76f963d585dd582c78bbaf554185d5d4">submit_blocks</a> (const T1 first_index, const T2 index_after_last, F &amp;&amp;block, const std::size_t num_blocks=0, const <a class="el" href="namespace_b_s.html#a76f70ed782c6c8c95fbb1e7d3cb4656e">priority_t</a> <a class="el" href="namespace_b_s.html#ae1a882c1a2584cb3570b567595c8027ba20e966bd58a0ecab6eecb8d1cbdd022b">priority</a>=0)</td></tr>
<tr class="memdesc:a76f963d585dd582c78bbaf554185d5d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parallelize a loop by automatically splitting it into blocks and submitting each block separately to the queue, with the specified priority. The block function takes two arguments, the start and end of the block, so that it is only called once per block, but it is up to the user make sure the block function correctly deals with all the indices in each block. Returns a <span class="tt"><a class="el" href="class_b_s_1_1multi__future.html" title="A helper class to facilitate waiting for and/or getting the results of multiple futures at once.">BS::multi_future</a></span> that contains the futures for all of the blocks.  <br /></td></tr>
<tr class="memitem:a51c236089dc40e33b2181ed66d6368fb" id="r_a51c236089dc40e33b2181ed66d6368fb"><td class="memTemplParams" colspan="2">template&lt;typename T1, typename T2, typename T = common_index_type_t&lt;T1, T2&gt;, typename F&gt; </td></tr>
<tr class="memitem:a51c236089dc40e33b2181ed66d6368fb template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_b_s_1_1multi__future.html">multi_future</a>&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a51c236089dc40e33b2181ed66d6368fb">submit_loop</a> (const T1 first_index, const T2 index_after_last, F &amp;&amp;loop, const std::size_t num_blocks=0, const <a class="el" href="namespace_b_s.html#a76f70ed782c6c8c95fbb1e7d3cb4656e">priority_t</a> <a class="el" href="namespace_b_s.html#ae1a882c1a2584cb3570b567595c8027ba20e966bd58a0ecab6eecb8d1cbdd022b">priority</a>=0)</td></tr>
<tr class="memdesc:a51c236089dc40e33b2181ed66d6368fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parallelize a loop by automatically splitting it into blocks and submitting each block separately to the queue, with the specified priority. The loop function takes one argument, the loop index, so that it is called many times per block. It must have no return value. Returns a <span class="tt"><a class="el" href="class_b_s_1_1multi__future.html" title="A helper class to facilitate waiting for and/or getting the results of multiple futures at once.">BS::multi_future</a></span> that contains the futures for all of the blocks.  <br /></td></tr>
<tr class="memitem:ac915668ff39e7e45013b94dd5905ed1b" id="r_ac915668ff39e7e45013b94dd5905ed1b"><td class="memTemplParams" colspan="2">template&lt;typename T1, typename T2, typename T = common_index_type_t&lt;T1, T2&gt;, typename F, typename R = std::invoke_result_t&lt;std::decay_t&lt;F&gt;, T&gt;&gt; </td></tr>
<tr class="memitem:ac915668ff39e7e45013b94dd5905ed1b template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_b_s_1_1multi__future.html">multi_future</a>&lt; R &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac915668ff39e7e45013b94dd5905ed1b">submit_sequence</a> (const T1 first_index, const T2 index_after_last, F &amp;&amp;sequence, const <a class="el" href="namespace_b_s.html#a76f70ed782c6c8c95fbb1e7d3cb4656e">priority_t</a> <a class="el" href="namespace_b_s.html#ae1a882c1a2584cb3570b567595c8027ba20e966bd58a0ecab6eecb8d1cbdd022b">priority</a>=0)</td></tr>
<tr class="memdesc:ac915668ff39e7e45013b94dd5905ed1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submit a sequence of tasks enumerated by indices to the queue, with the specified priority. The sequence function takes one argument, the task index, and will be called once per index. Returns a <span class="tt"><a class="el" href="class_b_s_1_1multi__future.html" title="A helper class to facilitate waiting for and/or getting the results of multiple futures at once.">BS::multi_future</a></span> that contains the futures for all of the tasks.  <br /></td></tr>
<tr class="memitem:a2cc53c258968877b3d54b5abb9cf4b4d" id="r_a2cc53c258968877b3d54b5abb9cf4b4d"><td class="memTemplParams" colspan="2">template&lt;typename F, typename R = std::invoke_result_t&lt;std::decay_t&lt;F&gt;&gt;&gt; </td></tr>
<tr class="memitem:a2cc53c258968877b3d54b5abb9cf4b4d template"><td class="memItemLeft" align="right" valign="top">std::future&lt; R &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2cc53c258968877b3d54b5abb9cf4b4d">submit_task</a> (F &amp;&amp;task, const <a class="el" href="namespace_b_s.html#a76f70ed782c6c8c95fbb1e7d3cb4656e">priority_t</a> <a class="el" href="namespace_b_s.html#ae1a882c1a2584cb3570b567595c8027ba20e966bd58a0ecab6eecb8d1cbdd022b">priority</a>=0)</td></tr>
<tr class="memdesc:a2cc53c258968877b3d54b5abb9cf4b4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submit a function with no arguments into the task queue, with the specified priority. To submit a function with arguments, enclose it in a lambda expression. If the function has a return value, get a future for the eventual returned value. If the function has no return value, get an <span class="tt">std::future&lt;void&gt;</span> which can be used to wait until the task finishes.  <br /></td></tr>
<tr class="memitem:abdd07a7dc1b479c69703e52b202915df" id="r_abdd07a7dc1b479c69703e52b202915df"><td class="memItemLeft" align="right" valign="top"><a id="abdd07a7dc1b479c69703e52b202915df" name="abdd07a7dc1b479c69703e52b202915df"></a>
BS_THREAD_POOL_IF_PAUSE_ENABLED void&#160;</td><td class="memItemRight" valign="bottom"><b>unpause</b> ()</td></tr>
<tr class="memdesc:abdd07a7dc1b479c69703e52b202915df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unpause the pool. The workers will resume retrieving new tasks out of the queue. Only enabled if the flag <span class="tt">BS:tp::pause</span> is enabled in the template parameter. <br /></td></tr>
<tr class="memitem:ae4fdcde4657ca01e3f6d0af108284809" id="r_ae4fdcde4657ca01e3f6d0af108284809"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae4fdcde4657ca01e3f6d0af108284809">wait</a> ()</td></tr>
<tr class="memdesc:ae4fdcde4657ca01e3f6d0af108284809"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for tasks to be completed. Normally, this function waits for all tasks, both those that are currently running in the threads and those that are still waiting in the queue. However, if the pool is paused, this function only waits for the currently running tasks (otherwise it would wait forever). Note: To wait for just one specific task, use <span class="tt"><a class="el" href="#a2cc53c258968877b3d54b5abb9cf4b4d" title="Submit a function with no arguments into the task queue, with the specified priority....">submit_task()</a></span> instead, and call the <span class="tt"><a class="el" href="#ae4fdcde4657ca01e3f6d0af108284809" title="Wait for tasks to be completed. Normally, this function waits for all tasks, both those that are curr...">wait()</a></span> member function of the generated future.  <br /></td></tr>
<tr class="memitem:a96220f6f2002518d7ab590ed1bd4224d" id="r_a96220f6f2002518d7ab590ed1bd4224d"><td class="memTemplParams" colspan="2">template&lt;typename R, typename P&gt; </td></tr>
<tr class="memitem:a96220f6f2002518d7ab590ed1bd4224d template"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a96220f6f2002518d7ab590ed1bd4224d">wait_for</a> (const std::chrono::duration&lt; R, P &gt; &amp;duration)</td></tr>
<tr class="memdesc:a96220f6f2002518d7ab590ed1bd4224d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for tasks to be completed, but stop waiting after the specified duration has passed.  <br /></td></tr>
<tr class="memitem:adc4d2f2e851c96e6b9caf7b26384e7d3" id="r_adc4d2f2e851c96e6b9caf7b26384e7d3"><td class="memTemplParams" colspan="2">template&lt;typename C, typename D&gt; </td></tr>
<tr class="memitem:adc4d2f2e851c96e6b9caf7b26384e7d3 template"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adc4d2f2e851c96e6b9caf7b26384e7d3">wait_until</a> (const std::chrono::time_point&lt; C, D &gt; &amp;timeout_time)</td></tr>
<tr class="memdesc:adc4d2f2e851c96e6b9caf7b26384e7d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for tasks to be completed, but stop waiting after the specified time point has been reached.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-static-attribs" class="groupheader"><a id="pub-static-attribs" name="pub-static-attribs"></a>
静的公開変数類</h2></td></tr>
<tr class="memitem:a309bd24967f1e4ba0ea9c2023d996528" id="r_a309bd24967f1e4ba0ea9c2023d996528"><td class="memItemLeft" align="right" valign="top"><a id="a309bd24967f1e4ba0ea9c2023d996528" name="a309bd24967f1e4ba0ea9c2023d996528"></a>
static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><b>priority_enabled</b> = (OptFlags &amp; <a class="el" href="namespace_b_s.html#ae1a882c1a2584cb3570b567595c8027ba20e966bd58a0ecab6eecb8d1cbdd022b">tp::priority</a>) != 0</td></tr>
<tr class="memdesc:a309bd24967f1e4ba0ea9c2023d996528"><td class="mdescLeft">&#160;</td><td class="mdescRight">A flag indicating whether task priority is enabled. <br /></td></tr>
<tr class="memitem:a82be32990782f7758d78564f5edd5f9c" id="r_a82be32990782f7758d78564f5edd5f9c"><td class="memItemLeft" align="right" valign="top"><a id="a82be32990782f7758d78564f5edd5f9c" name="a82be32990782f7758d78564f5edd5f9c"></a>
static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><b>pause_enabled</b> = (OptFlags &amp; <a class="el" href="namespace_b_s.html#ae1a882c1a2584cb3570b567595c8027ba2573e91242c7973901b7862e47cd7af9">tp::pause</a>) != 0</td></tr>
<tr class="memdesc:a82be32990782f7758d78564f5edd5f9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">A flag indicating whether pausing is enabled. <br /></td></tr>
<tr class="memitem:af152196df62efee67e774cf4b191e174" id="r_af152196df62efee67e774cf4b191e174"><td class="memItemLeft" align="right" valign="top"><a id="af152196df62efee67e774cf4b191e174" name="af152196df62efee67e774cf4b191e174"></a>
static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><b>wait_deadlock_checks_enabled</b> = (OptFlags &amp; <a class="el" href="namespace_b_s.html#ae1a882c1a2584cb3570b567595c8027ba1f051a409d60424953a4b4de63c7e156">tp::wait_deadlock_checks</a>) != 0</td></tr>
<tr class="memdesc:af152196df62efee67e774cf4b191e174"><td class="mdescLeft">&#160;</td><td class="mdescRight">A flag indicating whether wait deadlock checks are enabled. <br /></td></tr>
</table>
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">詳解</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;<a class="el" href="namespace_b_s.html#aacc613e815ee0fd22f6277d882b47356">opt_t</a> OptFlags = tp::none&gt;<br />
class BS::thread_pool&lt; OptFlags &gt;</div><p>A fast, lightweight, modern, and easy-to-use C++17/C++20/C++23 thread pool class. </p>
<dl class="tparams"><dt>テンプレート引数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OptFlags</td><td>A bitmask of flags which can be used to enable optional features. The flags are members of the <span class="tt"><a class="el" href="namespace_b_s.html#ae1a882c1a2584cb3570b567595c8027b" title="An enumeration of flags to be used in the bitmask template parameter of BS::thread_pool to enable opt...">BS::tp</a></span> enumeration: <span class="tt"><a class="el" href="namespace_b_s.html#ae1a882c1a2584cb3570b567595c8027ba20e966bd58a0ecab6eecb8d1cbdd022b" title="Enable task priority.">BS::tp::priority</a></span>, <span class="tt"><a class="el" href="namespace_b_s.html#ae1a882c1a2584cb3570b567595c8027ba2573e91242c7973901b7862e47cd7af9" title="Enable pausing.">BS::tp::pause</a></span>, and <span class="tt"><a class="el" href="namespace_b_s.html#ae1a882c1a2584cb3570b567595c8027ba1f051a409d60424953a4b4de63c7e156" title="Enable wait deadlock checks.">BS::tp::wait_deadlock_checks</a></span>. The default is <span class="tt"><a class="el" href="namespace_b_s.html#ae1a882c1a2584cb3570b567595c8027ba5b2f2bd1d71de1fa047ae7846bebd786" title="No optional features enabled.">BS::tp::none</a></span>, which disables all optional features. To enable multiple features, use the bitwise OR operator <span class="tt">|</span>, e.g. <span class="tt"><a class="el" href="namespace_b_s.html#ae1a882c1a2584cb3570b567595c8027ba20e966bd58a0ecab6eecb8d1cbdd022b" title="Enable task priority.">BS::tp::priority</a> | <a class="el" href="namespace_b_s.html#ae1a882c1a2584cb3570b567595c8027ba2573e91242c7973901b7862e47cd7af9" title="Enable pausing.">BS::tp::pause</a></span>. </td></tr>
  </table>
  </dd>
</dl>
</div><a name="doc-constructors" id="doc-constructors"></a><h2 id="header-doc-constructors" class="groupheader">構築子と解体子</h2>
<a id="a0e0296afdd18d144fd96d27945426529" name="a0e0296afdd18d144fd96d27945426529"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e0296afdd18d144fd96d27945426529">&#9670;&#160;</a></span>thread_pool() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespace_b_s.html#aacc613e815ee0fd22f6277d882b47356">opt_t</a> OptFlags = tp::none&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_b_s_1_1thread__pool.html">BS::thread_pool</a>&lt; OptFlags &gt;::thread_pool </td>
          <td>(</td>
          <td class="paramtype">const std::size_t</td>          <td class="paramname"><span class="paramname"><em>num_threads</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel explicit">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a new thread pool with the specified number of threads. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">num_threads</td><td>The number of threads to use. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0c2bfc615db57530a97ae789987ae6d0" name="a0c2bfc615db57530a97ae789987ae6d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c2bfc615db57530a97ae789987ae6d0">&#9670;&#160;</a></span>thread_pool() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespace_b_s.html#aacc613e815ee0fd22f6277d882b47356">opt_t</a> OptFlags = tp::none&gt; </div>
<div class="memtemplate">
template&lt;BS_THREAD_POOL_INIT_FUNC_CONCEPT(F)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_b_s_1_1thread__pool.html">BS::thread_pool</a>&lt; OptFlags &gt;::thread_pool </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>init</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel explicit">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a new thread pool with the specified initialization function. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">init</td><td>An initialization function to run in each thread before it starts executing any submitted tasks. The function must have no return value, and can either take one argument, the thread index of type <span class="tt">std::size_t</span>, or zero arguments. It will be executed exactly once per thread, when the thread is first constructed. The initialization function must not throw any exceptions, as that will result in program termination. Any exceptions must be handled explicitly within the function. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a60e6550ac7332ead9af50936ae5c5a3d" name="a60e6550ac7332ead9af50936ae5c5a3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60e6550ac7332ead9af50936ae5c5a3d">&#9670;&#160;</a></span>thread_pool() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespace_b_s.html#aacc613e815ee0fd22f6277d882b47356">opt_t</a> OptFlags = tp::none&gt; </div>
<div class="memtemplate">
template&lt;BS_THREAD_POOL_INIT_FUNC_CONCEPT(F)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_b_s_1_1thread__pool.html">BS::thread_pool</a>&lt; OptFlags &gt;::thread_pool </td>
          <td>(</td>
          <td class="paramtype">const std::size_t</td>          <td class="paramname"><span class="paramname"><em>num_threads</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>init</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a new thread pool with the specified number of threads and initialization function. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">num_threads</td><td>The number of threads to use. </td></tr>
    <tr><td class="paramname">init</td><td>An initialization function to run in each thread before it starts executing any submitted tasks. The function must have no return value, and can either take one argument, the thread index of type <span class="tt">std::size_t</span>, or zero arguments. It will be executed exactly once per thread, when the thread is first constructed. The initialization function must not throw any exceptions, as that will result in program termination. Any exceptions must be handled explicitly within the function. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">関数詳解</h2>
<a id="a2227c23c57235a364397aff24dbe35c9" name="a2227c23c57235a364397aff24dbe35c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2227c23c57235a364397aff24dbe35c9">&#9670;&#160;</a></span>detach_blocks()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespace_b_s.html#aacc613e815ee0fd22f6277d882b47356">opt_t</a> OptFlags = tp::none&gt; </div>
<div class="memtemplate">
template&lt;typename T1, typename T2, typename T = common_index_type_t&lt;T1, T2&gt;, typename F&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_b_s_1_1thread__pool.html">BS::thread_pool</a>&lt; OptFlags &gt;::detach_blocks </td>
          <td>(</td>
          <td class="paramtype">const T1</td>          <td class="paramname"><span class="paramname"><em>first_index</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2</td>          <td class="paramname"><span class="paramname"><em>index_after_last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>block</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t</td>          <td class="paramname"><span class="paramname"><em>num_blocks</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_b_s.html#a76f70ed782c6c8c95fbb1e7d3cb4656e">priority_t</a></td>          <td class="paramname"><span class="paramname"><em>priority</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parallelize a loop by automatically splitting it into blocks and submitting each block separately to the queue, with the specified priority. The block function takes two arguments, the start and end of the block, so that it is only called once per block, but it is up to the user make sure the block function correctly deals with all the indices in each block. Does not return a <span class="tt"><a class="el" href="class_b_s_1_1multi__future.html" title="A helper class to facilitate waiting for and/or getting the results of multiple futures at once.">BS::multi_future</a></span>, so the user must use <span class="tt"><a class="el" href="#ae4fdcde4657ca01e3f6d0af108284809" title="Wait for tasks to be completed. Normally, this function waits for all tasks, both those that are curr...">wait()</a></span> or some other method to ensure that the loop finishes executing, otherwise bad things will happen. </p>
<dl class="tparams"><dt>テンプレート引数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>The type of the first index. Should be a signed or unsigned integer. </td></tr>
    <tr><td class="paramname">T2</td><td>The type of the index after the last index. Should be a signed or unsigned integer. </td></tr>
    <tr><td class="paramname">F</td><td>The type of the function to loop through. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">first_index</td><td>The first index in the loop. </td></tr>
    <tr><td class="paramname">index_after_last</td><td>The index after the last index in the loop. The loop will iterate from <span class="tt">first_index</span> to <span class="tt">(index_after_last - 1)</span> inclusive. In other words, it will be equivalent to <span class="tt">for (T i = first_index; i &lt; index_after_last; ++i)</span>. Note that if <span class="tt">index_after_last &lt;= first_index</span>, no blocks will be submitted. </td></tr>
    <tr><td class="paramname">block</td><td>A function that will be called once per block. Should take exactly two arguments: the first index in the block and the index after the last index in the block. <span class="tt">block(start, end)</span> should typically involve a loop of the form <span class="tt">for (T i = start; i &lt; end; ++i)</span>. </td></tr>
    <tr><td class="paramname">num_blocks</td><td>The maximum number of blocks to split the loop into. The default is 0, which means the number of blocks will be equal to the number of threads in the pool. </td></tr>
    <tr><td class="paramname">priority</td><td>The priority of the tasks. Should be between -128 and +127 (a signed 8-bit integer). The default is 0. Only taken into account if the flag <span class="tt">BS:tp::priority</span> is enabled in the template parameter, otherwise has no effect. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a24a2a5d7219f89fff6aa7b33bc8a7994" name="a24a2a5d7219f89fff6aa7b33bc8a7994"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24a2a5d7219f89fff6aa7b33bc8a7994">&#9670;&#160;</a></span>detach_loop()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespace_b_s.html#aacc613e815ee0fd22f6277d882b47356">opt_t</a> OptFlags = tp::none&gt; </div>
<div class="memtemplate">
template&lt;typename T1, typename T2, typename T = common_index_type_t&lt;T1, T2&gt;, typename F&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_b_s_1_1thread__pool.html">BS::thread_pool</a>&lt; OptFlags &gt;::detach_loop </td>
          <td>(</td>
          <td class="paramtype">const T1</td>          <td class="paramname"><span class="paramname"><em>first_index</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2</td>          <td class="paramname"><span class="paramname"><em>index_after_last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>loop</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t</td>          <td class="paramname"><span class="paramname"><em>num_blocks</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_b_s.html#a76f70ed782c6c8c95fbb1e7d3cb4656e">priority_t</a></td>          <td class="paramname"><span class="paramname"><em>priority</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parallelize a loop by automatically splitting it into blocks and submitting each block separately to the queue, with the specified priority. The loop function takes one argument, the loop index, so that it is called many times per block. Does not return a <span class="tt"><a class="el" href="class_b_s_1_1multi__future.html" title="A helper class to facilitate waiting for and/or getting the results of multiple futures at once.">BS::multi_future</a></span>, so the user must use <span class="tt"><a class="el" href="#ae4fdcde4657ca01e3f6d0af108284809" title="Wait for tasks to be completed. Normally, this function waits for all tasks, both those that are curr...">wait()</a></span> or some other method to ensure that the loop finishes executing, otherwise bad things will happen. </p>
<dl class="tparams"><dt>テンプレート引数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>The type of the first index. Should be a signed or unsigned integer. </td></tr>
    <tr><td class="paramname">T2</td><td>The type of the index after the last index. Should be a signed or unsigned integer. </td></tr>
    <tr><td class="paramname">F</td><td>The type of the function to loop through. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">first_index</td><td>The first index in the loop. </td></tr>
    <tr><td class="paramname">index_after_last</td><td>The index after the last index in the loop. The loop will iterate from <span class="tt">first_index</span> to <span class="tt">(index_after_last - 1)</span> inclusive. In other words, it will be equivalent to <span class="tt">for (T i = first_index; i &lt; index_after_last; ++i)</span>. Note that if <span class="tt">index_after_last &lt;= first_index</span>, no blocks will be submitted. </td></tr>
    <tr><td class="paramname">loop</td><td>The function to loop through. Will be called once per index, many times per block. Should take exactly one argument: the loop index. </td></tr>
    <tr><td class="paramname">num_blocks</td><td>The maximum number of blocks to split the loop into. The default is 0, which means the number of blocks will be equal to the number of threads in the pool. </td></tr>
    <tr><td class="paramname">priority</td><td>The priority of the tasks. Should be between -128 and +127 (a signed 8-bit integer). The default is 0. Only taken into account if the flag <span class="tt">BS:tp::priority</span> is enabled in the template parameter, otherwise has no effect. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="affb462961cfe82a65097a4999f22ce8a" name="affb462961cfe82a65097a4999f22ce8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affb462961cfe82a65097a4999f22ce8a">&#9670;&#160;</a></span>detach_sequence()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespace_b_s.html#aacc613e815ee0fd22f6277d882b47356">opt_t</a> OptFlags = tp::none&gt; </div>
<div class="memtemplate">
template&lt;typename T1, typename T2, typename T = common_index_type_t&lt;T1, T2&gt;, typename F&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_b_s_1_1thread__pool.html">BS::thread_pool</a>&lt; OptFlags &gt;::detach_sequence </td>
          <td>(</td>
          <td class="paramtype">const T1</td>          <td class="paramname"><span class="paramname"><em>first_index</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2</td>          <td class="paramname"><span class="paramname"><em>index_after_last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>sequence</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_b_s.html#a76f70ed782c6c8c95fbb1e7d3cb4656e">priority_t</a></td>          <td class="paramname"><span class="paramname"><em>priority</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Submit a sequence of tasks enumerated by indices to the queue, with the specified priority. The sequence function takes one argument, the task index, and will be called once per index. Does not return a <span class="tt"><a class="el" href="class_b_s_1_1multi__future.html" title="A helper class to facilitate waiting for and/or getting the results of multiple futures at once.">BS::multi_future</a></span>, so the user must use <span class="tt"><a class="el" href="#ae4fdcde4657ca01e3f6d0af108284809" title="Wait for tasks to be completed. Normally, this function waits for all tasks, both those that are curr...">wait()</a></span> or some other method to ensure that the sequence finishes executing, otherwise bad things will happen. </p>
<dl class="tparams"><dt>テンプレート引数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>The type of the first index. Should be a signed or unsigned integer. </td></tr>
    <tr><td class="paramname">T2</td><td>The type of the index after the last index. Should be a signed or unsigned integer. </td></tr>
    <tr><td class="paramname">F</td><td>The type of the function used to define the sequence. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">first_index</td><td>The first index in the sequence. </td></tr>
    <tr><td class="paramname">index_after_last</td><td>The index after the last index in the sequence. The sequence will iterate from <span class="tt">first_index</span> to <span class="tt">(index_after_last - 1)</span> inclusive. In other words, it will be equivalent to <span class="tt">for (T i = first_index; i &lt; index_after_last; ++i)</span>. Note that if <span class="tt">index_after_last &lt;= first_index</span>, no tasks will be submitted. </td></tr>
    <tr><td class="paramname">sequence</td><td>The function used to define the sequence. Will be called once per index. Should take exactly one argument, the index. </td></tr>
    <tr><td class="paramname">priority</td><td>The priority of the tasks. Should be between -128 and +127 (a signed 8-bit integer). The default is 0. Only taken into account if the flag <span class="tt">BS:tp::priority</span> is enabled in the template parameter, otherwise has no effect. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac5effe10fd4156ea28c7a5c61997c6e7" name="ac5effe10fd4156ea28c7a5c61997c6e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5effe10fd4156ea28c7a5c61997c6e7">&#9670;&#160;</a></span>detach_task()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespace_b_s.html#aacc613e815ee0fd22f6277d882b47356">opt_t</a> OptFlags = tp::none&gt; </div>
<div class="memtemplate">
template&lt;typename F&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_b_s_1_1thread__pool.html">BS::thread_pool</a>&lt; OptFlags &gt;::detach_task </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>task</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_b_s.html#a76f70ed782c6c8c95fbb1e7d3cb4656e">priority_t</a></td>          <td class="paramname"><span class="paramname"><em>priority</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Submit a function with no arguments and no return value into the task queue, with the specified priority. To submit a function with arguments, enclose it in a lambda expression. Does not return a future, so the user must use <span class="tt"><a class="el" href="#ae4fdcde4657ca01e3f6d0af108284809" title="Wait for tasks to be completed. Normally, this function waits for all tasks, both those that are curr...">wait()</a></span> or some other method to ensure that the task finishes executing, otherwise bad things will happen. </p>
<dl class="tparams"><dt>テンプレート引数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>The type of the function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">task</td><td>The function to submit. </td></tr>
    <tr><td class="paramname">priority</td><td>The priority of the task. Should be between -128 and +127 (a signed 8-bit integer). The default is 0. Only taken into account if the flag <span class="tt">BS:tp::priority</span> is enabled in the template parameter, otherwise has no effect. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a70a96809451e3b894b4914f73943b8b8" name="a70a96809451e3b894b4914f73943b8b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70a96809451e3b894b4914f73943b8b8">&#9670;&#160;</a></span>get_tasks_queued()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespace_b_s.html#aacc613e815ee0fd22f6277d882b47356">opt_t</a> OptFlags = tp::none&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="class_b_s_1_1thread__pool.html">BS::thread_pool</a>&lt; OptFlags &gt;::get_tasks_queued </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of tasks currently waiting in the queue to be executed by the threads. </p>
<dl class="section return"><dt>戻り値</dt><dd>The number of queued tasks. </dd></dl>

</div>
</div>
<a id="af797cf1b1c5290330beef12fc44a213f" name="af797cf1b1c5290330beef12fc44a213f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af797cf1b1c5290330beef12fc44a213f">&#9670;&#160;</a></span>get_tasks_running()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespace_b_s.html#aacc613e815ee0fd22f6277d882b47356">opt_t</a> OptFlags = tp::none&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="class_b_s_1_1thread__pool.html">BS::thread_pool</a>&lt; OptFlags &gt;::get_tasks_running </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of tasks currently being executed by the threads. </p>
<dl class="section return"><dt>戻り値</dt><dd>The number of running tasks. </dd></dl>

</div>
</div>
<a id="a8d29b6cfcb1a688a1bd0ec2cfd827b24" name="a8d29b6cfcb1a688a1bd0ec2cfd827b24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d29b6cfcb1a688a1bd0ec2cfd827b24">&#9670;&#160;</a></span>get_tasks_total()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespace_b_s.html#aacc613e815ee0fd22f6277d882b47356">opt_t</a> OptFlags = tp::none&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="class_b_s_1_1thread__pool.html">BS::thread_pool</a>&lt; OptFlags &gt;::get_tasks_total </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the total number of unfinished tasks: either still waiting in the queue, or running in a thread. Note that <span class="tt"><a class="el" href="#a8d29b6cfcb1a688a1bd0ec2cfd827b24" title="Get the total number of unfinished tasks: either still waiting in the queue, or running in a thread....">get_tasks_total()</a> == <a class="el" href="#a70a96809451e3b894b4914f73943b8b8" title="Get the number of tasks currently waiting in the queue to be executed by the threads.">get_tasks_queued()</a> + <a class="el" href="#af797cf1b1c5290330beef12fc44a213f" title="Get the number of tasks currently being executed by the threads.">get_tasks_running()</a></span>. </p>
<dl class="section return"><dt>戻り値</dt><dd>The total number of tasks. </dd></dl>

</div>
</div>
<a id="ab8ff9b7b79739ae9240833a9b939de65" name="ab8ff9b7b79739ae9240833a9b939de65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8ff9b7b79739ae9240833a9b939de65">&#9670;&#160;</a></span>get_thread_count()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespace_b_s.html#aacc613e815ee0fd22f6277d882b47356">opt_t</a> OptFlags = tp::none&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="class_b_s_1_1thread__pool.html">BS::thread_pool</a>&lt; OptFlags &gt;::get_thread_count </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of threads in the pool. </p>
<dl class="section return"><dt>戻り値</dt><dd>The number of threads. </dd></dl>

</div>
</div>
<a id="a8292a17d2c183df3f02c89804b70f4ec" name="a8292a17d2c183df3f02c89804b70f4ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8292a17d2c183df3f02c89804b70f4ec">&#9670;&#160;</a></span>get_thread_ids()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespace_b_s.html#aacc613e815ee0fd22f6277d882b47356">opt_t</a> OptFlags = tp::none&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; thread_t::id &gt; <a class="el" href="class_b_s_1_1thread__pool.html">BS::thread_pool</a>&lt; OptFlags &gt;::get_thread_ids </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a vector containing the unique identifiers for each of the pool's threads, as obtained by <span class="tt">std::thread::get_id()</span> (or <span class="tt">std::jthread::get_id()</span> in C++20 and later). </p>
<dl class="section return"><dt>戻り値</dt><dd>The unique thread identifiers. </dd></dl>

</div>
</div>
<a id="a0e45f81e64dc34df12705c95132620b3" name="a0e45f81e64dc34df12705c95132620b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e45f81e64dc34df12705c95132620b3">&#9670;&#160;</a></span>is_paused()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespace_b_s.html#aacc613e815ee0fd22f6277d882b47356">opt_t</a> OptFlags = tp::none&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">BS_THREAD_POOL_IF_PAUSE_ENABLED bool <a class="el" href="class_b_s_1_1thread__pool.html">BS::thread_pool</a>&lt; OptFlags &gt;::is_paused </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check whether the pool is currently paused. Only enabled if the flag <span class="tt">BS:tp::pause</span> is enabled in the template parameter. </p>
<dl class="section return"><dt>戻り値</dt><dd><span class="tt">true</span> if the pool is paused, <span class="tt">false</span> if it is not paused. </dd></dl>

</div>
</div>
<a id="a4a473029de41c6467945a9930fce7991" name="a4a473029de41c6467945a9930fce7991"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a473029de41c6467945a9930fce7991">&#9670;&#160;</a></span>reset() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespace_b_s.html#aacc613e815ee0fd22f6277d882b47356">opt_t</a> OptFlags = tp::none&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_b_s_1_1thread__pool.html">BS::thread_pool</a>&lt; OptFlags &gt;::reset </td>
          <td>(</td>
          <td class="paramtype">const std::size_t</td>          <td class="paramname"><span class="paramname"><em>num_threads</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reset the pool with a new number of threads. Waits for all currently running tasks to be completed, then destroys all threads in the pool and creates a new thread pool with the new number of threads. Any tasks that were waiting in the queue before the pool was reset will then be executed by the new threads. If the pool was paused before resetting it, the new pool will be paused as well. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">num_threads</td><td>The number of threads to use. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a59eee365de519f55dd421b524ee6b663" name="a59eee365de519f55dd421b524ee6b663"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59eee365de519f55dd421b524ee6b663">&#9670;&#160;</a></span>reset() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespace_b_s.html#aacc613e815ee0fd22f6277d882b47356">opt_t</a> OptFlags = tp::none&gt; </div>
<div class="memtemplate">
template&lt;BS_THREAD_POOL_INIT_FUNC_CONCEPT(F)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_b_s_1_1thread__pool.html">BS::thread_pool</a>&lt; OptFlags &gt;::reset </td>
          <td>(</td>
          <td class="paramtype">const std::size_t</td>          <td class="paramname"><span class="paramname"><em>num_threads</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>init</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reset the pool with a new number of threads and a new initialization function. Waits for all currently running tasks to be completed, then destroys all threads in the pool and creates a new thread pool with the new number of threads and initialization function. Any tasks that were waiting in the queue before the pool was reset will then be executed by the new threads. If the pool was paused before resetting it, the new pool will be paused as well. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">num_threads</td><td>The number of threads to use. </td></tr>
    <tr><td class="paramname">init</td><td>An initialization function to run in each thread before it starts executing any submitted tasks. The function must have no return value, and can either take one argument, the thread index of type <span class="tt">std::size_t</span>, or zero arguments. It will be executed exactly once per thread, when the thread is first constructed. The initialization function must not throw any exceptions, as that will result in program termination. Any exceptions must be handled explicitly within the function. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9f123ac3f05c1925b5941c1bed0f5a6d" name="a9f123ac3f05c1925b5941c1bed0f5a6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f123ac3f05c1925b5941c1bed0f5a6d">&#9670;&#160;</a></span>reset() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespace_b_s.html#aacc613e815ee0fd22f6277d882b47356">opt_t</a> OptFlags = tp::none&gt; </div>
<div class="memtemplate">
template&lt;BS_THREAD_POOL_INIT_FUNC_CONCEPT(F)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_b_s_1_1thread__pool.html">BS::thread_pool</a>&lt; OptFlags &gt;::reset </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>init</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reset the pool with the total number of hardware threads available, as reported by the implementation, and a new initialization function. Waits for all currently running tasks to be completed, then destroys all threads in the pool and creates a new thread pool with the new number of threads and initialization function. Any tasks that were waiting in the queue before the pool was reset will then be executed by the new threads. If the pool was paused before resetting it, the new pool will be paused as well. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">init</td><td>An initialization function to run in each thread before it starts executing any submitted tasks. The function must have no return value, and can either take one argument, the thread index of type <span class="tt">std::size_t</span>, or zero arguments. It will be executed exactly once per thread, when the thread is first constructed. The initialization function must not throw any exceptions, as that will result in program termination. Any exceptions must be handled explicitly within the function. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a847135c2217e88c590b9ca4be39b6c7a" name="a847135c2217e88c590b9ca4be39b6c7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a847135c2217e88c590b9ca4be39b6c7a">&#9670;&#160;</a></span>set_cleanup_func()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespace_b_s.html#aacc613e815ee0fd22f6277d882b47356">opt_t</a> OptFlags = tp::none&gt; </div>
<div class="memtemplate">
template&lt;BS_THREAD_POOL_INIT_FUNC_CONCEPT(F)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_b_s_1_1thread__pool.html">BS::thread_pool</a>&lt; OptFlags &gt;::set_cleanup_func </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>cleanup</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the thread pool's cleanup function. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">cleanup</td><td>A cleanup function to run in each thread right before it is destroyed, which will happen when the pool is destructed or reset. The function must have no return value, and can either take one argument, the thread index of type <span class="tt">std::size_t</span>, or zero arguments. The cleanup function must not throw any exceptions, as that will result in program termination. Any exceptions must be handled explicitly within the function. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a76f963d585dd582c78bbaf554185d5d4" name="a76f963d585dd582c78bbaf554185d5d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76f963d585dd582c78bbaf554185d5d4">&#9670;&#160;</a></span>submit_blocks()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespace_b_s.html#aacc613e815ee0fd22f6277d882b47356">opt_t</a> OptFlags = tp::none&gt; </div>
<div class="memtemplate">
template&lt;typename T1, typename T2, typename T = common_index_type_t&lt;T1, T2&gt;, typename F, typename R = std::invoke_result_t&lt;std::decay_t&lt;F&gt;, T, T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_b_s_1_1multi__future.html">multi_future</a>&lt; R &gt; <a class="el" href="class_b_s_1_1thread__pool.html">BS::thread_pool</a>&lt; OptFlags &gt;::submit_blocks </td>
          <td>(</td>
          <td class="paramtype">const T1</td>          <td class="paramname"><span class="paramname"><em>first_index</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2</td>          <td class="paramname"><span class="paramname"><em>index_after_last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>block</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t</td>          <td class="paramname"><span class="paramname"><em>num_blocks</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_b_s.html#a76f70ed782c6c8c95fbb1e7d3cb4656e">priority_t</a></td>          <td class="paramname"><span class="paramname"><em>priority</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parallelize a loop by automatically splitting it into blocks and submitting each block separately to the queue, with the specified priority. The block function takes two arguments, the start and end of the block, so that it is only called once per block, but it is up to the user make sure the block function correctly deals with all the indices in each block. Returns a <span class="tt"><a class="el" href="class_b_s_1_1multi__future.html" title="A helper class to facilitate waiting for and/or getting the results of multiple futures at once.">BS::multi_future</a></span> that contains the futures for all of the blocks. </p>
<dl class="tparams"><dt>テンプレート引数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>The type of the first index. Should be a signed or unsigned integer. </td></tr>
    <tr><td class="paramname">T2</td><td>The type of the index after the last index. Should be a signed or unsigned integer. </td></tr>
    <tr><td class="paramname">F</td><td>The type of the function to loop through. </td></tr>
    <tr><td class="paramname">R</td><td>The return type of the function to loop through (can be <span class="tt">void</span>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">first_index</td><td>The first index in the loop. </td></tr>
    <tr><td class="paramname">index_after_last</td><td>The index after the last index in the loop. The loop will iterate from <span class="tt">first_index</span> to <span class="tt">(index_after_last - 1)</span> inclusive. In other words, it will be equivalent to <span class="tt">for (T i = first_index; i &lt; index_after_last; ++i)</span>. Note that if <span class="tt">index_after_last &lt;= first_index</span>, no blocks will be submitted, and an empty <span class="tt"><a class="el" href="class_b_s_1_1multi__future.html" title="A helper class to facilitate waiting for and/or getting the results of multiple futures at once.">BS::multi_future</a></span> will be returned. </td></tr>
    <tr><td class="paramname">block</td><td>A function that will be called once per block. Should take exactly two arguments: the first index in the block and the index after the last index in the block. <span class="tt">block(start, end)</span> should typically involve a loop of the form <span class="tt">for (T i = start; i &lt; end; ++i)</span>. </td></tr>
    <tr><td class="paramname">num_blocks</td><td>The maximum number of blocks to split the loop into. The default is 0, which means the number of blocks will be equal to the number of threads in the pool. </td></tr>
    <tr><td class="paramname">priority</td><td>The priority of the tasks. Should be between -128 and +127 (a signed 8-bit integer). The default is 0. Only taken into account if the flag <span class="tt">BS:tp::priority</span> is enabled in the template parameter, otherwise has no effect. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>A <span class="tt"><a class="el" href="class_b_s_1_1multi__future.html" title="A helper class to facilitate waiting for and/or getting the results of multiple futures at once.">BS::multi_future</a></span> that can be used to wait for all the blocks to finish. If the block function returns a value, the <span class="tt"><a class="el" href="class_b_s_1_1multi__future.html" title="A helper class to facilitate waiting for and/or getting the results of multiple futures at once.">BS::multi_future</a></span> can also be used to obtain the values returned by each block. </dd></dl>

</div>
</div>
<a id="a51c236089dc40e33b2181ed66d6368fb" name="a51c236089dc40e33b2181ed66d6368fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51c236089dc40e33b2181ed66d6368fb">&#9670;&#160;</a></span>submit_loop()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespace_b_s.html#aacc613e815ee0fd22f6277d882b47356">opt_t</a> OptFlags = tp::none&gt; </div>
<div class="memtemplate">
template&lt;typename T1, typename T2, typename T = common_index_type_t&lt;T1, T2&gt;, typename F&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_b_s_1_1multi__future.html">multi_future</a>&lt; void &gt; <a class="el" href="class_b_s_1_1thread__pool.html">BS::thread_pool</a>&lt; OptFlags &gt;::submit_loop </td>
          <td>(</td>
          <td class="paramtype">const T1</td>          <td class="paramname"><span class="paramname"><em>first_index</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2</td>          <td class="paramname"><span class="paramname"><em>index_after_last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>loop</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t</td>          <td class="paramname"><span class="paramname"><em>num_blocks</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_b_s.html#a76f70ed782c6c8c95fbb1e7d3cb4656e">priority_t</a></td>          <td class="paramname"><span class="paramname"><em>priority</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parallelize a loop by automatically splitting it into blocks and submitting each block separately to the queue, with the specified priority. The loop function takes one argument, the loop index, so that it is called many times per block. It must have no return value. Returns a <span class="tt"><a class="el" href="class_b_s_1_1multi__future.html" title="A helper class to facilitate waiting for and/or getting the results of multiple futures at once.">BS::multi_future</a></span> that contains the futures for all of the blocks. </p>
<dl class="tparams"><dt>テンプレート引数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>The type of the first index. Should be a signed or unsigned integer. </td></tr>
    <tr><td class="paramname">T2</td><td>The type of the index after the last index. Should be a signed or unsigned integer. </td></tr>
    <tr><td class="paramname">F</td><td>The type of the function to loop through. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">first_index</td><td>The first index in the loop. </td></tr>
    <tr><td class="paramname">index_after_last</td><td>The index after the last index in the loop. The loop will iterate from <span class="tt">first_index</span> to <span class="tt">(index_after_last - 1)</span> inclusive. In other words, it will be equivalent to <span class="tt">for (T i = first_index; i &lt; index_after_last; ++i)</span>. Note that if <span class="tt">index_after_last &lt;= first_index</span>, no tasks will be submitted, and an empty <span class="tt"><a class="el" href="class_b_s_1_1multi__future.html" title="A helper class to facilitate waiting for and/or getting the results of multiple futures at once.">BS::multi_future</a></span> will be returned. </td></tr>
    <tr><td class="paramname">loop</td><td>The function to loop through. Will be called once per index, many times per block. Should take exactly one argument: the loop index. It cannot have a return value. </td></tr>
    <tr><td class="paramname">num_blocks</td><td>The maximum number of blocks to split the loop into. The default is 0, which means the number of blocks will be equal to the number of threads in the pool. </td></tr>
    <tr><td class="paramname">priority</td><td>The priority of the tasks. Should be between -128 and +127 (a signed 8-bit integer). The default is 0. Only taken into account if the flag <span class="tt">BS:tp::priority</span> is enabled in the template parameter, otherwise has no effect. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>A <span class="tt"><a class="el" href="class_b_s_1_1multi__future.html" title="A helper class to facilitate waiting for and/or getting the results of multiple futures at once.">BS::multi_future</a></span> that can be used to wait for all the blocks to finish. </dd></dl>

</div>
</div>
<a id="ac915668ff39e7e45013b94dd5905ed1b" name="ac915668ff39e7e45013b94dd5905ed1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac915668ff39e7e45013b94dd5905ed1b">&#9670;&#160;</a></span>submit_sequence()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespace_b_s.html#aacc613e815ee0fd22f6277d882b47356">opt_t</a> OptFlags = tp::none&gt; </div>
<div class="memtemplate">
template&lt;typename T1, typename T2, typename T = common_index_type_t&lt;T1, T2&gt;, typename F, typename R = std::invoke_result_t&lt;std::decay_t&lt;F&gt;, T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_b_s_1_1multi__future.html">multi_future</a>&lt; R &gt; <a class="el" href="class_b_s_1_1thread__pool.html">BS::thread_pool</a>&lt; OptFlags &gt;::submit_sequence </td>
          <td>(</td>
          <td class="paramtype">const T1</td>          <td class="paramname"><span class="paramname"><em>first_index</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2</td>          <td class="paramname"><span class="paramname"><em>index_after_last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>sequence</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_b_s.html#a76f70ed782c6c8c95fbb1e7d3cb4656e">priority_t</a></td>          <td class="paramname"><span class="paramname"><em>priority</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Submit a sequence of tasks enumerated by indices to the queue, with the specified priority. The sequence function takes one argument, the task index, and will be called once per index. Returns a <span class="tt"><a class="el" href="class_b_s_1_1multi__future.html" title="A helper class to facilitate waiting for and/or getting the results of multiple futures at once.">BS::multi_future</a></span> that contains the futures for all of the tasks. </p>
<dl class="tparams"><dt>テンプレート引数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>The type of the first index. Should be a signed or unsigned integer. </td></tr>
    <tr><td class="paramname">T2</td><td>The type of the index after the last index. Should be a signed or unsigned integer. </td></tr>
    <tr><td class="paramname">F</td><td>The type of the function used to define the sequence. </td></tr>
    <tr><td class="paramname">R</td><td>The return type of the function used to define the sequence (can be <span class="tt">void</span>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">first_index</td><td>The first index in the sequence. </td></tr>
    <tr><td class="paramname">index_after_last</td><td>The index after the last index in the sequence. The sequence will iterate from <span class="tt">first_index</span> to <span class="tt">(index_after_last - 1)</span> inclusive. In other words, it will be equivalent to <span class="tt">for (T i = first_index; i &lt; index_after_last; ++i)</span>. Note that if <span class="tt">index_after_last &lt;= first_index</span>, no tasks will be submitted, and an empty <span class="tt"><a class="el" href="class_b_s_1_1multi__future.html" title="A helper class to facilitate waiting for and/or getting the results of multiple futures at once.">BS::multi_future</a></span> will be returned. </td></tr>
    <tr><td class="paramname">sequence</td><td>The function used to define the sequence. Will be called once per index. Should take exactly one argument, the index. </td></tr>
    <tr><td class="paramname">priority</td><td>The priority of the tasks. Should be between -128 and +127 (a signed 8-bit integer). The default is 0. Only taken into account if the flag <span class="tt">BS:tp::priority</span> is enabled in the template parameter, otherwise has no effect. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>A <span class="tt"><a class="el" href="class_b_s_1_1multi__future.html" title="A helper class to facilitate waiting for and/or getting the results of multiple futures at once.">BS::multi_future</a></span> that can be used to wait for all the tasks to finish. If the sequence function returns a value, the <span class="tt"><a class="el" href="class_b_s_1_1multi__future.html" title="A helper class to facilitate waiting for and/or getting the results of multiple futures at once.">BS::multi_future</a></span> can also be used to obtain the values returned by each task. </dd></dl>

</div>
</div>
<a id="a2cc53c258968877b3d54b5abb9cf4b4d" name="a2cc53c258968877b3d54b5abb9cf4b4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cc53c258968877b3d54b5abb9cf4b4d">&#9670;&#160;</a></span>submit_task()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespace_b_s.html#aacc613e815ee0fd22f6277d882b47356">opt_t</a> OptFlags = tp::none&gt; </div>
<div class="memtemplate">
template&lt;typename F, typename R = std::invoke_result_t&lt;std::decay_t&lt;F&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::future&lt; R &gt; <a class="el" href="class_b_s_1_1thread__pool.html">BS::thread_pool</a>&lt; OptFlags &gt;::submit_task </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>task</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_b_s.html#a76f70ed782c6c8c95fbb1e7d3cb4656e">priority_t</a></td>          <td class="paramname"><span class="paramname"><em>priority</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Submit a function with no arguments into the task queue, with the specified priority. To submit a function with arguments, enclose it in a lambda expression. If the function has a return value, get a future for the eventual returned value. If the function has no return value, get an <span class="tt">std::future&lt;void&gt;</span> which can be used to wait until the task finishes. </p>
<dl class="tparams"><dt>テンプレート引数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>The type of the function. </td></tr>
    <tr><td class="paramname">R</td><td>The return type of the function (can be <span class="tt">void</span>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">task</td><td>The function to submit. </td></tr>
    <tr><td class="paramname">priority</td><td>The priority of the task. Should be between -128 and +127 (a signed 8-bit integer). The default is 0. Only taken into account if the flag <span class="tt">BS:tp::priority</span> is enabled in the template parameter, otherwise has no effect. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>A future to be used later to wait for the function to finish executing and/or obtain its returned value if it has one. </dd></dl>

</div>
</div>
<a id="ae4fdcde4657ca01e3f6d0af108284809" name="ae4fdcde4657ca01e3f6d0af108284809"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4fdcde4657ca01e3f6d0af108284809">&#9670;&#160;</a></span>wait()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespace_b_s.html#aacc613e815ee0fd22f6277d882b47356">opt_t</a> OptFlags = tp::none&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_b_s_1_1thread__pool.html">BS::thread_pool</a>&lt; OptFlags &gt;::wait </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wait for tasks to be completed. Normally, this function waits for all tasks, both those that are currently running in the threads and those that are still waiting in the queue. However, if the pool is paused, this function only waits for the currently running tasks (otherwise it would wait forever). Note: To wait for just one specific task, use <span class="tt"><a class="el" href="#a2cc53c258968877b3d54b5abb9cf4b4d" title="Submit a function with no arguments into the task queue, with the specified priority....">submit_task()</a></span> instead, and call the <span class="tt"><a class="el" href="#ae4fdcde4657ca01e3f6d0af108284809" title="Wait for tasks to be completed. Normally, this function waits for all tasks, both those that are curr...">wait()</a></span> member function of the generated future. </p>
<dl class="exception"><dt>例外</dt><dd>
  <table class="exception">
    <tr><td class="paramname">`wait_deadlock`</td><td>if called from within a thread of the same pool, which would result in a deadlock. Only enabled if the flag <span class="tt">BS:tp::wait_deadlock_checks</span> is enabled in the template parameter. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a96220f6f2002518d7ab590ed1bd4224d" name="a96220f6f2002518d7ab590ed1bd4224d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96220f6f2002518d7ab590ed1bd4224d">&#9670;&#160;</a></span>wait_for()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespace_b_s.html#aacc613e815ee0fd22f6277d882b47356">opt_t</a> OptFlags = tp::none&gt; </div>
<div class="memtemplate">
template&lt;typename R, typename P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_b_s_1_1thread__pool.html">BS::thread_pool</a>&lt; OptFlags &gt;::wait_for </td>
          <td>(</td>
          <td class="paramtype">const std::chrono::duration&lt; R, P &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>duration</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wait for tasks to be completed, but stop waiting after the specified duration has passed. </p>
<dl class="tparams"><dt>テンプレート引数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>An arithmetic type representing the number of ticks to wait. </td></tr>
    <tr><td class="paramname">P</td><td>An <span class="tt">std::ratio</span> representing the length of each tick in seconds. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">duration</td><td>The amount of time to wait. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd><span class="tt">true</span> if all tasks finished running, <span class="tt">false</span> if the duration expired but some tasks are still running. </dd></dl>
<dl class="exception"><dt>例外</dt><dd>
  <table class="exception">
    <tr><td class="paramname">`wait_deadlock`</td><td>if called from within a thread of the same pool, which would result in a deadlock. Only enabled if the flag <span class="tt">BS:tp::wait_deadlock_checks</span> is enabled in the template parameter. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adc4d2f2e851c96e6b9caf7b26384e7d3" name="adc4d2f2e851c96e6b9caf7b26384e7d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc4d2f2e851c96e6b9caf7b26384e7d3">&#9670;&#160;</a></span>wait_until()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespace_b_s.html#aacc613e815ee0fd22f6277d882b47356">opt_t</a> OptFlags = tp::none&gt; </div>
<div class="memtemplate">
template&lt;typename C, typename D&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_b_s_1_1thread__pool.html">BS::thread_pool</a>&lt; OptFlags &gt;::wait_until </td>
          <td>(</td>
          <td class="paramtype">const std::chrono::time_point&lt; C, D &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>timeout_time</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wait for tasks to be completed, but stop waiting after the specified time point has been reached. </p>
<dl class="tparams"><dt>テンプレート引数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">C</td><td>The type of the clock used to measure time. </td></tr>
    <tr><td class="paramname">D</td><td>An <span class="tt">std::chrono::duration</span> type used to indicate the time point. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeout_time</td><td>The time point at which to stop waiting. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd><span class="tt">true</span> if all tasks finished running, <span class="tt">false</span> if the time point was reached but some tasks are still running. </dd></dl>
<dl class="exception"><dt>例外</dt><dd>
  <table class="exception">
    <tr><td class="paramname">`wait_deadlock`</td><td>if called from within a thread of the same pool, which would result in a deadlock. Only enabled if the flag <span class="tt">BS:tp::wait_deadlock_checks</span> is enabled in the template parameter. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>このクラス詳解は次のファイルから抽出されました:<ul>
<li><a class="el" href="_b_s__thread__pool_8hpp_source.html">BS_thread_pool.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a href="namespace_b_s.html">BS</a></li><li class="navelem"><a href="class_b_s_1_1thread__pool.html">thread_pool</a></li>
    <li class="footer">構築: <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0 </li>
  </ul>
</div>
</body>
</html>
